From f18cfda1024c6bd7f307c16b4d054258e58e1ded Mon Sep 17 00:00:00 2001
From: michalbiesek <michal.biesek@intel.com>
Date: Mon, 20 Apr 2020 12:37:51 +0200
Subject: [PATCH 06/16] Add PMEM mechanism to zmalloc module

- use MEMKIND_DAX_KMEM for PMEM allocations
- use threshold to distinguish allocaitons between DRAM and PMEM

Co-authored-by: jschmieg <jakub.schmiegel@intel.com>
---
 src/zmalloc.c | 189 ++++++++++++++++++++++++++++++++++++++++++++++----
 src/zmalloc.h |   4 ++
 2 files changed, 181 insertions(+), 12 deletions(-)

diff --git a/src/zmalloc.c b/src/zmalloc.c
index 04e2bbf9e..4a4a36724 100644
--- a/src/zmalloc.c
+++ b/src/zmalloc.c
@@ -57,6 +57,9 @@ void zlibc_free(void *ptr) {
 #endif
 #endif
 
+#define DRAM_LOCATION 0
+#define PMEM_LOCATION 1
+
 /* Explicitly override malloc/free etc when using tcmalloc. */
 #if defined(USE_TCMALLOC)
 #define malloc(size) tc_malloc(size)
@@ -74,8 +77,49 @@ void zlibc_free(void *ptr) {
 #include <errno.h>
 #define malloc(size) memkind_malloc(MEMKIND_DEFAULT,size)
 #define calloc(count,size) memkind_calloc(MEMKIND_DEFAULT,count,size)
-#define realloc(ptr,size) memkind_realloc(MEMKIND_DEFAULT,ptr,size)
-#define free(ptr) memkind_free(MEMKIND_DEFAULT,ptr)
+#define realloc_dram(ptr,size) memkind_realloc(MEMKIND_DEFAULT,ptr,size)
+#define realloc_pmem(ptr,size) memkind_realloc(MEMKIND_DAX_KMEM,ptr,size)
+#define free_dram(ptr) memkind_free(MEMKIND_DEFAULT,ptr)
+#define free_pmem(ptr) memkind_free(MEMKIND_DAX_KMEM,ptr)
+#endif
+
+#ifndef USE_MEMKIND
+static void zmalloc_pmem_not_available(void) {
+    fprintf(stderr, "zmalloc: PMEM function is available only for memkind allocator\n");
+    fflush(stderr);
+    abort();
+}
+#define free_dram(ptr) free(ptr)
+#define realloc_dram(ptr,size) realloc(ptr,size)
+
+static int zmalloc_is_pmem(void * ptr) {
+    (void)(ptr);
+    return DRAM_LOCATION;
+}
+
+static void zfree_pmem(void *ptr) {
+    (void)(ptr);
+    zmalloc_pmem_not_available();
+}
+
+static void *zmalloc_pmem(size_t size) {
+    (void)(size);
+    zmalloc_pmem_not_available();
+    return NULL;
+}
+
+static void *zcalloc_pmem(size_t size) {
+    (void)(size);
+    zmalloc_pmem_not_available();
+    return NULL;
+}
+
+static void *zrealloc_pmem(void *ptr, size_t size) {
+    (void)(ptr);
+    (void)(size);
+    zmalloc_pmem_not_available();
+    return NULL;
+}
 #endif
 
 #define update_zmalloc_stat_alloc(__n) do { \
@@ -84,14 +128,27 @@ void zlibc_free(void *ptr) {
     atomicIncr(used_memory,__n); \
 } while(0)
 
+#define update_zmalloc_pmem_stat_alloc(__n) do { \
+    size_t _n = (__n); \
+    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
+    atomicIncr(used_pmem_memory,__n); \
+} while(0)
+
 #define update_zmalloc_stat_free(__n) do { \
     size_t _n = (__n); \
     if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
     atomicDecr(used_memory,__n); \
 } while(0)
 
+#define update_zmalloc_pmem_stat_free(__n) do { \
+    size_t _n = (__n); \
+    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
+    atomicDecr(used_pmem_memory,__n); \
+} while(0)
+
 static size_t pmem_threshold = UINT_MAX;
 static size_t used_memory = 0;
+static size_t used_pmem_memory = 0;
 pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;
 
 static void zmalloc_default_oom(size_t size) {
@@ -103,9 +160,8 @@ static void zmalloc_default_oom(size_t size) {
 
 static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;
 
-void *zmalloc(size_t size) {
+void *zmalloc_dram(size_t size) {
     void *ptr = malloc(size+PREFIX_SIZE);
-
 #ifdef USE_MEMKIND
     if (!ptr && errno==ENOMEM) zmalloc_oom_handler(size);
 #else
@@ -121,6 +177,95 @@ void *zmalloc(size_t size) {
 #endif
 }
 
+#ifdef USE_MEMKIND
+static int zmalloc_is_pmem(void * ptr) {
+    struct memkind *temp_kind = memkind_detect_kind(ptr);
+    return (temp_kind == MEMKIND_DEFAULT) ? DRAM_LOCATION : PMEM_LOCATION;
+}
+
+static void zfree_pmem(void *ptr) {
+#ifndef HAVE_MALLOC_SIZE
+    void *realptr;
+    size_t oldsize;
+#endif
+
+    if (ptr == NULL) return;
+#ifdef HAVE_MALLOC_SIZE
+    update_zmalloc_pmem_stat_free(zmalloc_size(ptr));
+    free_pmem(ptr);
+#else
+    realptr = (char*)ptr-PREFIX_SIZE;
+    oldsize = *((size_t*)realptr);
+    update_zmalloc_pmem_stat_free(oldsize+PREFIX_SIZE);
+    free_pmem(realptr);
+#endif
+}
+
+static void *zmalloc_pmem(size_t size) {
+    void *ptr = memkind_malloc(MEMKIND_DAX_KMEM, size+PREFIX_SIZE);
+    if (!ptr && errno==ENOMEM) zmalloc_oom_handler(size);
+#ifdef HAVE_MALLOC_SIZE
+    update_zmalloc_pmem_stat_alloc(zmalloc_size(ptr));
+    return ptr;
+#else
+    *((size_t*)ptr) = size;
+    update_zmalloc_pmem_stat_alloc(size+PREFIX_SIZE);
+    return (char*)ptr+PREFIX_SIZE;
+#endif
+}
+
+static void *zcalloc_pmem(size_t size) {
+    void *ptr = memkind_calloc(MEMKIND_DAX_KMEM, 1, size+PREFIX_SIZE);
+
+    if (!ptr && errno==ENOMEM) zmalloc_oom_handler(size);
+#ifdef HAVE_MALLOC_SIZE
+    update_zmalloc_pmem_stat_alloc(zmalloc_size(ptr));
+    return ptr;
+#else
+    *((size_t*)ptr) = size;
+    update_zmalloc_pmem_stat_alloc(size+PREFIX_SIZE);
+    return (char*)ptr+PREFIX_SIZE;
+#endif
+}
+
+static void *zrealloc_pmem(void *ptr, size_t size) {
+#ifndef HAVE_MALLOC_SIZE
+    void *realptr;
+#endif
+    size_t oldsize;
+    void *newptr;
+
+    if (size == 0 && ptr != NULL) {
+        zfree_pmem(ptr);
+        return NULL;
+    }
+    if (ptr == NULL) return zmalloc(size);
+#ifdef HAVE_MALLOC_SIZE
+    oldsize = zmalloc_size(ptr);
+    newptr = realloc_pmem(ptr,size);
+    if (!newptr) zmalloc_oom_handler(size);
+
+    update_zmalloc_pmem_stat_free(oldsize);
+    update_zmalloc_pmem_stat_alloc(zmalloc_size(newptr));
+    return newptr;
+#else
+    realptr = (char*)ptr-PREFIX_SIZE;
+    oldsize = *((size_t*)realptr);
+    newptr = realloc_pmem(realptr,size+PREFIX_SIZE);
+    if (!newptr) zmalloc_oom_handler(size);
+
+    *((size_t*)newptr) = size;
+    update_zmalloc_pmem_stat_free(oldsize+PREFIX_SIZE);
+    update_zmalloc_pmem_stat_alloc(size+PREFIX_SIZE);
+    return (char*)newptr+PREFIX_SIZE;
+#endif
+}
+#endif
+
+void *zmalloc(size_t size) {
+    return (size < pmem_threshold) ? zmalloc_dram(size) : zmalloc_pmem(size);
+}
+
 /* Allocation and free functions that bypass the thread cache
  * and go straight to the allocator arena bins.
  * Currently implemented only for jemalloc. Used for online defragmentation. */
@@ -139,7 +284,7 @@ void zfree_no_tcache(void *ptr) {
 }
 #endif
 
-void *zcalloc(size_t size) {
+void *zcalloc_dram(size_t size) {
     void *ptr = calloc(1, size+PREFIX_SIZE);
 
     if (!ptr) zmalloc_oom_handler(size);
@@ -153,7 +298,11 @@ void *zcalloc(size_t size) {
 #endif
 }
 
-void *zrealloc(void *ptr, size_t size) {
+void *zcalloc(size_t size) {
+    return (size < pmem_threshold) ? zcalloc_dram(size) : zcalloc_pmem(size);
+}
+
+void *zrealloc_dram(void *ptr, size_t size) {
 #ifndef HAVE_MALLOC_SIZE
     void *realptr;
 #endif
@@ -161,13 +310,13 @@ void *zrealloc(void *ptr, size_t size) {
     void *newptr;
 
     if (size == 0 && ptr != NULL) {
-        zfree(ptr);
+        zfree_dram(ptr);
         return NULL;
     }
     if (ptr == NULL) return zmalloc(size);
 #ifdef HAVE_MALLOC_SIZE
     oldsize = zmalloc_size(ptr);
-    newptr = realloc(ptr,size);
+    newptr = realloc_dram(ptr,size);
     if (!newptr) zmalloc_oom_handler(size);
 
     update_zmalloc_stat_free(oldsize);
@@ -176,7 +325,7 @@ void *zrealloc(void *ptr, size_t size) {
 #else
     realptr = (char*)ptr-PREFIX_SIZE;
     oldsize = *((size_t*)realptr);
-    newptr = realloc(realptr,size+PREFIX_SIZE);
+    newptr = realloc_dram(realptr,size+PREFIX_SIZE);
     if (!newptr) zmalloc_oom_handler(size);
 
     *((size_t*)newptr) = size;
@@ -186,6 +335,14 @@ void *zrealloc(void *ptr, size_t size) {
 #endif
 }
 
+void *zrealloc(void *ptr, size_t size) {
+    if (!zmalloc_is_pmem(ptr)) {
+        return zrealloc_dram(ptr, size);
+    } else {
+        return zrealloc_pmem(ptr, size);
+    }
+}
+
 /* Provide zmalloc_size() for systems where this function is not provided by
  * malloc itself, given that in that case we store a header with this
  * information as the first bytes of every allocation. */
@@ -203,7 +360,7 @@ size_t zmalloc_usable(void *ptr) {
 }
 #endif
 
-void zfree(void *ptr) {
+void zfree_dram(void *ptr) {
 #ifndef HAVE_MALLOC_SIZE
     void *realptr;
     size_t oldsize;
@@ -212,15 +369,23 @@ void zfree(void *ptr) {
     if (ptr == NULL) return;
 #ifdef HAVE_MALLOC_SIZE
     update_zmalloc_stat_free(zmalloc_size(ptr));
-    free(ptr);
+    free_dram(ptr);
 #else
     realptr = (char*)ptr-PREFIX_SIZE;
     oldsize = *((size_t*)realptr);
     update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
-    free(realptr);
+    free_dram(realptr);
 #endif
 }
 
+void zfree(void *ptr) {
+    if (!zmalloc_is_pmem(ptr)) {
+        zfree_dram(ptr);
+    } else {
+        zfree_pmem(ptr);
+    }
+}
+
 char *zstrdup(const char *s) {
     size_t l = strlen(s)+1;
     char *p = zmalloc(l);
diff --git a/src/zmalloc.h b/src/zmalloc.h
index 994dc53cc..974dcf678 100644
--- a/src/zmalloc.h
+++ b/src/zmalloc.h
@@ -90,6 +90,7 @@ void *zmalloc(size_t size);
 void *zcalloc(size_t size);
 void *zrealloc(void *ptr, size_t size);
 void zfree(void *ptr);
+void zfree_dram(void *ptr);
 char *zstrdup(const char *s);
 size_t zmalloc_used_memory(void);
 void zmalloc_set_oom_handler(void (*oom_handler)(size_t));
@@ -102,6 +103,9 @@ size_t zmalloc_get_smap_bytes_by_field(char *field, long pid);
 size_t zmalloc_get_memory_size(void);
 void zlibc_free(void *ptr);
 void zmalloc_set_threshold(size_t threshold);
+void *zmalloc_dram(size_t size);
+void *zcalloc_dram(size_t size);
+void *zrealloc_dram(void *ptr, size_t size);
 
 #ifdef HAVE_DEFRAG
 void zfree_no_tcache(void *ptr);
-- 
2.19.1.6.gb485710b

